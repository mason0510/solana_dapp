use std::cmp::min;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::pubkey::Pubkey;
use anchor_client::solana_sdk::signature::read_keypair_file;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, Cluster, EventContext};

use kingwo_nft::accounts as kingwo_nft_accounts;
use kingwo_nft::instruction as kingwo_nft_instruction;
//use basic_2::Counter;

use solana_client::{
    rpc_client::RpcClient,
    rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes, MemcmpEncoding},
    rpc_config::{RpcProgramAccountsConfig, RpcAccountInfoConfig},
};
use solana_sdk::program_pack::Pack;
use spl_token::{state::{Mint, Account}};
use solana_account_decoder::{UiAccountEncoding};

use anyhow::Result;
use solana_sdk::{pubkey, system_program};
// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;
use clap::Parser;
// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};
use rand::rngs::OsRng;
use std::rc::Rc;
use std::str::FromStr;
use std::time::Duration;
use spl_associated_token_account::create_associated_token_account;

#[derive(Parser, Debug)]
pub struct Opts {
    #[clap(long)]
    pub token_address: Pubkey,
    #[clap(long)]
    pub bridge_contract_pid: Pubkey,
    #[clap(long)]
    pub receiver_wallet: Pubkey,
}

const MPL_PROGRAM_ID: &'static str = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";

//const BRIDGE_CONTRACT: &'static str = "F1eqWRT9CUruLk9n4mX4fCYKDqSde9yLtveRaywx6vwn";
//const TOKEN_ADDRESS: &'static str = "7YYNXbfwd5i5scpez18fTkEh2MRHJXoMHPffnWNcpFYf";
const SENDER: &'static str = "9hUYW9s2c98GfjZb6JvW62BYEt3ryxGmeMBkhgSqmZtW";
const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: &'static str = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";


// This example assumes a local validator is running with the programs
// deployed at the addresses given by the CLI args.
fn main() -> Result<()> {
    println!("Starting test...");
    let opts = Opts::parse();

    // Wallet and cluster params.
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
        .expect("Example requires a keypair file");
    let url = Cluster::Custom(
        "https://api.devnet.solana.com".to_string(),
        "wss://api.devnet.solana.com/".to_string(),
    );

    // Client.
    let client = Client::new_with_options(url, Rc::new(payer), CommitmentConfig::processed());

    // Run tests.
    //composite(&client, opts.composite_pid)?;
    transfer_nft(&client, opts)?;
    //println!("{:?}",token_account);
    // Success.
    Ok(())
}

fn transfer_nft(client: &Client, params: Opts) -> Result<()> {
    let program = client.program(params.bridge_contract_pid); //BGzwb76jQtDP9hpho7WDSzFSYSJUbbZq4Jkpggb4aiuA

    // `Create` parameters.
    let counter = Keypair::generate(&mut OsRng);
    let  (new_pda_account, _sandboxBump) =  Pubkey::find_program_address(
        &[
            &params.receiver_wallet.to_bytes(),
            &Pubkey::from_str(MPL_PROGRAM_ID).unwrap().to_bytes(),
            &params.token_address.to_bytes()
        ],
        &Pubkey::from_str(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID).unwrap()
    );

    println!("counter {}",new_pda_account);
    let authority = program.payer();


    /***
    pub sender_token_account: Account<'info, token::TokenAccount>,
    #[account(mut)]
    pub owner_authority: Signer<'info>,
    #[account(mut)]
    pub receive_token_account:Account<'info,token::TokenAccount>,
    pub token_program: Program<'info, token::Token>,
    */
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");

    let payer2 = read_keypair_file(&*shellexpand::tilde("~/work/repo/solana/solana_dapp/my_wallet/1.json")).expect("Example requires a keypair file");

    let sender_token_account = get_token_account_by_wallet(payer.pubkey(),params.token_address).unwrap();
    let receiver_token_account = get_token_account_by_wallet(params.receiver_wallet,params.token_address);
    let receiver_token_account = receiver_token_account.unwrap_or(new_pda_account);
    let receiver_token_account = new_pda_account;
    // Build and send a transaction.
    /***
    ctx.accounts.associated_token_program.to_account_info(),
            a    pub sender_token_account: Account<'info, token::TokenAccount>,
    #[account(mut)]
    pub sender_authority: Signer<'info>,
    #[account(mut)]
    //pub to_token_account: UncheckedAccount<'info>,
    pub receiver_token_account:Account<'info,token::TokenAccount>,
    */
    //instructions
    println!("start request");
    let call_res = program
        .request()
        .instruction(
                //system_instruction::create_account()
            create_associated_token_account(&payer.pubkey(), &params.receiver_wallet, &params.token_address)
        )
        .signer(&payer)
        .accounts(kingwo_nft_accounts::Transfer {
            sender_authority: payer.pubkey(),
            sender_token_account,                                          //sender token account 9hUYW9s2c98GfjZb6JvW62BYEt3ryxGmeMBkhgSqmZtW
            receiver_token_account,                                        //receiver token account  5yNJwDPiXdGFQFULAtrwUgr1DrRiHT6adS4kLn9dxHuv
            token_program: Pubkey::from_str(MPL_PROGRAM_ID).unwrap(),  // SPL 官方合约写死   TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
            associated_token_program: Pubkey::from_str("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL").unwrap(),
            rent:Pubkey::from_str("SysvarRent111111111111111111111111111111111").unwrap(),
            system_program:Pubkey::from_str("11111111111111111111111111111111").unwrap(),
            mint: params.token_address,
        })//对应anchor合约中的context里面的结构体
        .args(kingwo_nft_instruction::Transfer)//对应函数中的费context函数，结构体类型名对应函数名，成员名对应参数
       ;//.send()?;
    println!("start request2 {:?}",call_res.instructions()?.len());

    println!("call_res {}", call_res.send()?);
    //let counter_account: Counter = program.account(counter.pubkey())?;

    //assert_eq!(counter_account.count, 0);

    println!("hello success!");

    Ok(())
}

fn get_token_account_by_wallet(wallet_pubkey: Pubkey,mint_pubkey: Pubkey) -> Option<Pubkey>{
    let rpc_url = String::from("https://api.devnet.solana.com");
    let connection = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    let filters = Some(vec![
        RpcFilterType::Memcmp(Memcmp {
            offset: 32,
            bytes: MemcmpEncodedBytes::Base58(wallet_pubkey.to_string()),
            encoding: Some(MemcmpEncoding::Binary),
        }),
        RpcFilterType::DataSize(165),
    ]);

    let accounts = connection.get_program_accounts_with_config(
        &Pubkey::from_str(MPL_PROGRAM_ID).unwrap(),
        RpcProgramAccountsConfig {
            filters,
            account_config: RpcAccountInfoConfig {
                encoding: Some(UiAccountEncoding::Base64),
                commitment: Some(connection.commitment()),
                ..RpcAccountInfoConfig::default()
            },
            ..RpcProgramAccountsConfig::default()
        },
    ).unwrap();

    println!("Found {:?} token account(s) for wallet {}: ", accounts.len(),wallet_pubkey.to_string());
    let token_account = accounts.iter().find(|&account| {
        let mint_token_account = Account::unpack_from_slice(account.1.data.as_slice()).unwrap();
        let mint_token_account = mint_token_account.mint.to_string();
        mint_pubkey.to_string() == mint_token_account
    });
    //todo: 不仅检查是否在当前program找到，还要检查所有的
    token_account.map(|token_account| token_account.0.to_owned())
}