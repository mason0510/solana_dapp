extern crate core;

use std::cmp::min;
use std::io::Error;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::signature::read_keypair_file;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, ClientError, Cluster, EventContext};
use mpl_token_metadata::instruction::{set_and_verify_collection,verify_collection};
use borsh::{BorshDeserialize, BorshSerialize};


use solana_client::{
    rpc_client::RpcClient,
    rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes, MemcmpEncoding},
    rpc_config::{RpcProgramAccountsConfig, RpcAccountInfoConfig},
};
use solana_sdk::program_pack::Pack;
use spl_token::{state::{Mint, Account}};
use solana_account_decoder::{UiAccountEncoding};

use anyhow::Result;
use solana_sdk::{client, system_program};
// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;
use clap::Parser;
// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};
use rand::rngs::OsRng;
use std::rc::Rc;
use std::str::FromStr;
use std::time::Duration;
use anchor_client::anchor_lang::Key;
use anchor_client::anchor_lang::prelude::{Pubkey, Sysvar};
use anchor_client::solana_client::nonce_utils::get_account;
use anchor_client::solana_sdk::nonce::State;
use mpl_token_metadata::pda::{find_master_edition_account, find_metadata_account};
use mpl_token_metadata::state::{Metadata, PREFIX, TokenMetadataAccount};
use solana_client::nonce_utils::get_account_with_commitment;
use solana_sdk::account_info::AccountInfo;
use spl_associated_token_account::{create_associated_token_account,get_associated_token_address};
use spl_associated_token_account::solana_program::pubkey;

#[cfg(feature = "serde-feature")]
use {
    serde::{Deserialize, Serialize},
    serde_with::{As, DisplayFromStr},
};

//import { TOKEN_PROGRAM_ID, createAssociatedTokenAccountInstruction, getAssociatedTokenAddress, createInitializeMintInstruction, MINT_SIZE } from '@solana/spl-token' // IGNORE THESE ERRORS IF ANY

use spl_token::instruction::initialize_mint;
use nft_mint_and_verify::instruction as nft_instructions;
use nft_mint_and_verify::accounts as nft_accounts;

use escrow_marketplace::instruction as market_instructions;
use escrow_marketplace::accounts as market_accounts;
use serde::{Deserialize,Serialize};
use solana_sdk::account::ReadableAccount;
use escrow_marketplace::constants::{MARKET_SETTING, ORDER_SIZE, SETTING_SIZE, VAULT_PREFIX, VAULT_SIGNER};

use escrow_marketplace::state::order::{SellOrder, Settings};
use crate::SPL_PROGRAM_ID;


pub fn find_metadata_pda(mint: &Pubkey) -> Pubkey {
    let (pda, _bump) = find_metadata_account(mint);

    pda
}

pub fn find_master_edition_pda(mint: &Pubkey) -> Pubkey {

    let (pda, _bump) = find_master_edition_account(mint);
    pda
}

pub fn get_acc(address: Pubkey) -> solana_sdk::account::Account{
    let rpc_client = RpcClient::new(
        "https://api.devnet.solana.com".to_string(),
    );
    rpc_client
        .get_account_with_commitment(&address, CommitmentConfig::processed()).unwrap()
        .value
        .ok_or(ClientError::AccountNotFound).unwrap()
}

//根据get_program_account过滤相关ata
pub fn get_token_account_by_wallet(wallet_pubkey: Pubkey,mint_pubkey: Pubkey) -> Option<Pubkey>{
    let rpc_url = String::from("https://api.devnet.solana.com");
    let connection = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    let filters = Some(vec![
        RpcFilterType::Memcmp(Memcmp {
            offset: 32,
            bytes: MemcmpEncodedBytes::Base58(wallet_pubkey.to_string()),
            encoding: Some(MemcmpEncoding::Binary),
        }),
        RpcFilterType::DataSize(165),
    ]);

    let accounts = connection.get_program_accounts_with_config(
        &Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
        RpcProgramAccountsConfig {
            filters,
            account_config: RpcAccountInfoConfig {
                encoding: Some(UiAccountEncoding::Base64),
                commitment: Some(connection.commitment()),
                ..RpcAccountInfoConfig::default()
            },
            ..RpcProgramAccountsConfig::default()
        },
    ).unwrap();

    println!("Found {:?} token account(s) for wallet {}: ", accounts.len(),wallet_pubkey.to_string());
    let token_account = accounts.iter().find(|&account| {
        let mint_token_account = Account::unpack_from_slice(account.1.data.as_slice()).unwrap();
        let mint_token_account = mint_token_account.mint.to_string();
        mint_pubkey.to_string() == mint_token_account
    });
    //todo: 不仅检查是否在当前program找到，还要检查所有的
    token_account.map(|token_account| token_account.0.to_owned())
}

fn spl_transfer(){
    todo!()
    /* let transfer_instruction = spl_token::instruction::transfer(
        &Pubkey::from_str(SPL_PROGRAM_ID).unwrap(), &receiver_token_account,
        &nft_token_account, &wallet3.pubkey(), &[&wallet3.pubkey()], 1).unwrap();
    let transfer_res = program
        .request()
        .instruction(
            transfer_instruction
        )
        .signer(&wallet3)
        .send().unwrap();*/
}

//update nft medata
fn update_metadata(){
    todo!()
}

fn get_lamport_balance(){
    todo!()
}

fn get_spl_token_balance(){
    todo!()
}