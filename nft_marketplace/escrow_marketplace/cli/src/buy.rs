extern crate core;

use std::cmp::min;
use std::io::Error;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::signature::read_keypair_file;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, ClientError, Cluster, EventContext};
use mpl_token_metadata::instruction::{set_and_verify_collection,verify_collection};
use borsh::{BorshDeserialize, BorshSerialize};


use solana_client::{
    rpc_client::RpcClient,
    rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes, MemcmpEncoding},
    rpc_config::{RpcProgramAccountsConfig, RpcAccountInfoConfig},
};
use solana_sdk::program_pack::Pack;
use spl_token::{state::{Mint, Account}};
use solana_account_decoder::{UiAccountEncoding};

use anyhow::Result;
use solana_sdk::{client, system_program};
// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;
use clap::Parser;
// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};
use rand::rngs::OsRng;
use std::rc::Rc;
use std::str::FromStr;
use std::time::Duration;
use anchor_client::anchor_lang::Key;
use anchor_client::anchor_lang::prelude::{Pubkey, Sysvar};
use anchor_client::solana_client::nonce_utils::get_account;
use anchor_client::solana_sdk::nonce::State;
use mpl_token_metadata::pda::{find_master_edition_account, find_metadata_account};
use mpl_token_metadata::state::{Metadata, PREFIX, TokenMetadataAccount};
use solana_client::nonce_utils::get_account_with_commitment;
use solana_sdk::account_info::AccountInfo;
use spl_associated_token_account::{create_associated_token_account,get_associated_token_address};
use spl_associated_token_account::solana_program::pubkey;

use spl_token::instruction::initialize_mint;
use nft_mint_and_verify::instruction as nft_instructions;
use nft_mint_and_verify::accounts as nft_accounts;

use escrow_marketplace::instruction as market_instructions;
use escrow_marketplace::accounts as market_accounts;
use serde::{Deserialize,Serialize};
use solana_sdk::account::ReadableAccount;
use escrow_marketplace::constants::{MARKET_SETTING, ORDER_SIZE, SETTING_SIZE, VAULT_PREFIX, VAULT_SIGNER};

use escrow_marketplace::state::order::{SellOrder, Settings};
use super::*;




fn buy_and_pay_kcoin(){
    todo!()
}

pub fn buy_and_pay_lamport(client: &Client, nft_mint_key: Pubkey,escrow_account_key: Pubkey){
    let program = client.program(Pubkey::from_str(ESCROW_MARKETPLACE).unwrap());
    let authority = program.payer();
    //5wEmePkkXAWYYvvWQDv4Mbenma1jWvzCbt3rK9ihmrqH
    let buyer = read_keypair_file(&*shellexpand::tilde("/Users/eddy/work/repo/solana/solana_dapp/my_wallet/2.json")).expect("Example requires a keypair file");
    let seller = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");

    let (vault_account_pda, _vault_account_bump) =   Pubkey::find_program_address(
        &[VAULT_PREFIX,nft_mint_key.as_ref()],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let (vault_authority_pda, _escrow_account_bump) =   Pubkey::find_program_address(
        &[VAULT_SIGNER,nft_mint_key.as_ref()],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let (market_setting_pda, _) =   Pubkey::find_program_address(
        &[MARKET_SETTING],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let seller_coin_account = get_associated_token_address(&seller.pubkey(), &Pubkey::from_str(K_COIN).unwrap());
    let seller_token_account = get_associated_token_address(&seller.pubkey(), &nft_mint_key);

    let buyer_coin_account = get_associated_token_address(&buyer.pubkey(), &Pubkey::from_str(K_COIN).unwrap());
    let buyer_token_account = get_associated_token_address(&buyer.pubkey(), &nft_mint_key);

    let buyer_res = program
        .request()
        .accounts(market_accounts::PayLamport{
            buyer: buyer.pubkey(),
            //buyer_coin_account,
            //k_coin_mint_account: Pubkey::from_str(K_COIN).unwrap(),
            nft_token_mint_account: nft_mint_key,
            buyer_token_account,
            //seller_coin_account,
            seller_token_account,
            seller: seller.pubkey(),
            escrow_account: escrow_account_key,
            vault_account: vault_account_pda,
            vault_authority: vault_authority_pda,
            setting_account: market_setting_pda,
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
            // sys account
            associated_token_program: Pubkey::from_str(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID).unwrap(),
            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(),
            rent: Pubkey::from_str(SYSTEM_RENT_ID).unwrap(),
        })
        .args(market_instructions::BuyAndPayLamport)
        .signer(&buyer)
        .send().unwrap();
    println!("finished pay lamport, cal res {}",buyer_res.to_string());
}
