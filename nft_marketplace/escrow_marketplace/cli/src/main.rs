use std::cmp::min;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::signature::read_keypair_file;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, ClientError, Cluster, EventContext};
use mpl_token_metadata::instruction::{set_and_verify_collection,verify_collection};

use solana_client::{
    rpc_client::RpcClient,
    rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes, MemcmpEncoding},
    rpc_config::{RpcProgramAccountsConfig, RpcAccountInfoConfig},
};
use solana_sdk::program_pack::Pack;
use spl_token::{state::{Mint, Account}};
use solana_account_decoder::{UiAccountEncoding};

use anyhow::Result;
use solana_sdk::{client, system_program};
// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;
use clap::Parser;
// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};
use rand::rngs::OsRng;
use std::rc::Rc;
use std::str::FromStr;
use std::time::Duration;
use anchor_client::anchor_lang::Key;
use anchor_client::anchor_lang::prelude::{Pubkey, Sysvar};
use anchor_client::solana_client::nonce_utils::get_account;
use anchor_client::solana_sdk::nonce::State;
use mpl_token_metadata::pda::{find_master_edition_account, find_metadata_account};
use mpl_token_metadata::state::{Metadata, PREFIX, TokenMetadataAccount};
use solana_client::nonce_utils::get_account_with_commitment;
use solana_sdk::account_info::AccountInfo;
use spl_associated_token_account::{create_associated_token_account,get_associated_token_address};
use spl_associated_token_account::solana_program::pubkey;

//import { TOKEN_PROGRAM_ID, createAssociatedTokenAccountInstruction, getAssociatedTokenAddress, createInitializeMintInstruction, MINT_SIZE } from '@solana/spl-token' // IGNORE THESE ERRORS IF ANY

use spl_token::instruction::initialize_mint;
use nft_mint_and_verify::instruction as nft_instructions;
use nft_mint_and_verify::accounts as nft_accounts;


use escrow_marketplace::instruction as market_instructions;
use escrow_marketplace::accounts as market_accounts;


#[derive(Parser, Debug)]
pub struct Opts {
    #[clap(long)]
    pub token_address: Pubkey,
    #[clap(long)]
    pub bridge_contract_pid: Pubkey,
    #[clap(long)]
    pub receiver_wallet: Pubkey,
}
//K coin
const K_COIN: &'static str = "5d1i4wKHhGXXkdZB22iKD1SqU6pkBeTCwFEMqo7xy39h";

const SPL_PROGRAM_ID: &'static str = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
//市场托管合约
const ESCROW_MARKETPLACE: &'static str = "Hv49DNdC6CUSwK3MWH5gj5BfLUU64r2ANXwdhaaRceGD";
//一键生成NFT的合约
const NFT_MINT_CONTRACT: &'static str = "9HiRJw3dYo2MV9B1WrqFfoNjWRPS19mjVDCPqAxuMPfb";
const SENDER: &'static str = "9hUYW9s2c98GfjZb6JvW62BYEt3ryxGmeMBkhgSqmZtW";
const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: &'static str = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
const SYSTEM_PROGRAM_ID: &'static str = "11111111111111111111111111111111";
const SYSTEM_RENT_ID: &'static str = "SysvarRent111111111111111111111111111111111";
const MPL_TOKEN_METADATA_ACCOUNT: &'static str = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";



pub fn find_metadata_pda(mint: &Pubkey) -> Pubkey {
    let (pda, _bump) = find_metadata_account(mint);

    pda
}

pub fn find_master_edition_pda(mint: &Pubkey) -> Pubkey {

    let (pda, _bump) = find_master_edition_account(mint);
    pda
}

pub fn get_acc(address: Pubkey) -> solana_sdk::account::Account{
    let rpc_client = RpcClient::new(
        "https://api.devnet.solana.com".to_string(),
    );
    rpc_client
        .get_account_with_commitment(&address, CommitmentConfig::processed()).unwrap()
        .value
        .ok_or(ClientError::AccountNotFound).unwrap()
}


fn get_token_account_by_wallet(wallet_pubkey: Pubkey,mint_pubkey: Pubkey) -> Option<Pubkey>{
    let rpc_url = String::from("https://api.devnet.solana.com");
    let connection = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    let filters = Some(vec![
        RpcFilterType::Memcmp(Memcmp {
            offset: 32,
            bytes: MemcmpEncodedBytes::Base58(wallet_pubkey.to_string()),
            encoding: Some(MemcmpEncoding::Binary),
        }),
        RpcFilterType::DataSize(165),
    ]);

    let accounts = connection.get_program_accounts_with_config(
        &Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
        RpcProgramAccountsConfig {
            filters,
            account_config: RpcAccountInfoConfig {
                encoding: Some(UiAccountEncoding::Base64),
                commitment: Some(connection.commitment()),
                ..RpcAccountInfoConfig::default()
            },
            ..RpcProgramAccountsConfig::default()
        },
    ).unwrap();

    println!("Found {:?} token account(s) for wallet {}: ", accounts.len(),wallet_pubkey.to_string());
    let token_account = accounts.iter().find(|&account| {
        let mint_token_account = Account::unpack_from_slice(account.1.data.as_slice()).unwrap();
        let mint_token_account = mint_token_account.mint.to_string();
        mint_pubkey.to_string() == mint_token_account
    });
    //todo: 不仅检查是否在当前program找到，还要检查所有的
    token_account.map(|token_account| token_account.0.to_owned())
}

// This example assumes a local validator is running with the programs
// deployed at the addresses given by the CLI args.
fn main() -> Result<()> {
    println!("Starting test...");
    let opts = Opts::parse();

    // Wallet and cluster params.
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
        .expect("Example requires a keypair file");
    let url = Cluster::Custom(
        "https://api.devnet.solana.com".to_string(),
        "wss://api.devnet.solana.com/".to_string(),
    );

    // Client.
    let client = Client::new_with_options(url, Rc::new(payer), CommitmentConfig::processed());
    //let mint_key = mint_nft(&client, opts)?;
    let mint_key= Pubkey::from_str("Hpp4QyZXHjm3S2GGCbWcjAfPMWuEYszwo53SKM5MCeLy").unwrap();
    //sell(&client,mint_key);
    //cancel(&client,mint_key);
    buy(&client,mint_key);

    //todo
    /***
    sell
    buy

    sell
    cancel
    */

    Ok(())
}

fn buy(client: &Client, nft_mint_key: Pubkey){
    let program = client.program(Pubkey::from_str(ESCROW_MARKETPLACE).unwrap());
    let authority = program.payer();
    //5wEmePkkXAWYYvvWQDv4Mbenma1jWvzCbt3rK9ihmrqH
    let buyer = read_keypair_file(&*shellexpand::tilde("/Users/eddy/work/repo/solana/solana_dapp/my_wallet/2.json")).expect("Example requires a keypair file");
    let seller = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");


    //let escrow_account = Keypair::new();
    let escrow_account_key = Pubkey::from_str("GgDrmmH6sroDTxPeHFWG2za3DhGykEVUzcHXtYcwvA6g").unwrap();

    let (vault_account_pda, _vault_account_bump) =   Pubkey::find_program_address(
        &[b"token-seed10"],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let (vault_authority_pda, _escrow_account_bump) =   Pubkey::find_program_address(
        &[b"escrow"],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let seller_coin_account = get_associated_token_address(&seller.pubkey(), &Pubkey::from_str(K_COIN).unwrap());
    let seller_token_account = get_associated_token_address(&seller.pubkey(), &nft_mint_key);

    let buyer_coin_account = get_associated_token_address(&buyer.pubkey(), &Pubkey::from_str(K_COIN).unwrap());
    let buyer_token_account = get_associated_token_address(&buyer.pubkey(), &nft_mint_key);

    println!("nft mint key {},vault_account_pda {},vault_authority_pda {}", nft_mint_key.to_string(),vault_account_pda,vault_authority_pda);

    let buyer_res = program
        .request()
        .accounts(market_accounts::Exchange{
            k_coin_mint_account: Pubkey::from_str(K_COIN).unwrap(),
            nft_token_mint_account: nft_mint_key,

            buyer: buyer.pubkey(),
            buyer_coin_account,
            buyer_token_account,
            seller_coin_account,
            seller_token_account,
            seller: seller.pubkey(),

            vault_account: vault_account_pda,
            vault_authority: vault_authority_pda,
            escrow_account: escrow_account_key,
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),

            // sys account
            associated_token_program: Pubkey::from_str(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID).unwrap(),
            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(),
            rent: Pubkey::from_str(SYSTEM_RENT_ID).unwrap(),
        })
        .args(market_instructions::Exchange)
        .signer(&buyer)
        .send().unwrap();
    println!("sell_res {}",buyer_res.to_string());
    println!("nft mint key {},vault_account_pda {}", nft_mint_key.to_string(),vault_account_pda);

}


fn cancel(client: &Client, nft_mint_key: Pubkey){
    let program = client.program(Pubkey::from_str(ESCROW_MARKETPLACE).unwrap());
    let authority = program.payer();
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");
    //let escrow_account = Keypair::new();
    let escrow_account_key = Pubkey::from_str("FJ9PetXXRRibBCM36RtXzCpB39UVSVEjAZFXArD2FbjU").unwrap();

    let (vault_account_pda, _vault_account_bump) =   Pubkey::find_program_address(
        &[b"token-seed10"],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let (vault_authority_pda, _escrow_account_bump) =   Pubkey::find_program_address(
          &[b"escrow"],
          &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
      );

    let seller_token_account = get_token_account_by_wallet(payer.pubkey(),nft_mint_key).unwrap();
    println!("nft mint key {},vault_account_pda {}", nft_mint_key.to_string(),vault_account_pda);


    let sell_res = program
        .request()
        .accounts(market_accounts::Cancel{
            initializer: payer.pubkey(),
            seller_token_account: seller_token_account,
            vault_account: vault_account_pda,
            vault_authority: vault_authority_pda,
            escrow_account: escrow_account_key,
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
        })
        .args(market_instructions::Cancel)
        .signer(&payer)
        .send().unwrap();
    println!("sell_res {}",sell_res.to_string());
    println!("nft mint key {},vault_account_pda {}", nft_mint_key.to_string(),vault_account_pda);

}

fn sell(client: &Client, nft_mint_key: Pubkey){
    let program = client.program(Pubkey::from_str(ESCROW_MARKETPLACE).unwrap());
    let authority = program.payer();
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");
    let escrow_account = Keypair::new();

    let (vault_account_pda, _vault_account_bump) =   Pubkey::find_program_address(
        &[b"token-seed10"],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

  let (vault_authority_pda, _escrow_account_bump) =   Pubkey::find_program_address(
        &[b"escrow"],
        &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap()
    );

    let seller_token_account = get_token_account_by_wallet(payer.pubkey(),nft_mint_key).unwrap();
    println!("escrow_account key {},seller_token_account {},vault_authority_pda {}", escrow_account.pubkey().to_string(),seller_token_account.to_string(),vault_authority_pda.to_string());
    println!("nft mint key {},vault_account_pda {}", nft_mint_key.to_string(),vault_account_pda);


    let sell_res = program
        .request()
        .instruction(
            system_instruction::create_account(
                &payer.pubkey(),
                &escrow_account.pubkey(),
                14476800,    //todo: 精确计算资源
                800u64,
                &Pubkey::from_str(ESCROW_MARKETPLACE).unwrap(),
            )
        )
        .accounts(market_accounts::Initialize{
            initializer: payer.pubkey(),
            nft_mint: nft_mint_key,

            vault_account: vault_account_pda,
            seller_token_account: seller_token_account,
            escrow_account: escrow_account.pubkey(),

            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(),
            rent: Pubkey::from_str(SYSTEM_RENT_ID).unwrap(),
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
        })
        .args(market_instructions::Initialize{_vault_account_bump:1,price:1_000_000_000}) //todo: delete _vault_account_bump
        .signer(&payer)
        .signer(&escrow_account)
        .send().unwrap();
    println!("sell_res {}",sell_res.to_string());
    println!("nft mint key {},vault_account_pda {}", nft_mint_key.to_string(),vault_account_pda);

}

fn mint_nft(client: &Client, params: Opts) -> Result<Pubkey> {
    let program = client.program(Pubkey::from_str(NFT_MINT_CONTRACT).unwrap()); //9HiRJw3dYo2MV9B1WrqFfoNjWRPS19mjVDCPqAxuMPfb
    let authority = program.payer();
    let to_wallet = program.payer();
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");
    let nft_mint_key = Keypair::new();
    println!("nft mint key {}", nft_mint_key.pubkey().to_string());

    //当前记忆碎皮的集合的meta_account,权限已经给了付鸿
    //let memorise_mint_account = "6P64iPbit6iUbwMj55pXXEu7GxUaE9jPVqWCmomyqPph";
    //当前礼物的集合 8zKSXBACKpaKvgDCYdDwpJGTVDSBCtAgucJpmR7gAyx5
    let memorise_mint_account = "8zKSXBACKpaKvgDCYdDwpJGTVDSBCtAgucJpmR7gAyx5";

    let nft_token_account = get_associated_token_address(&to_wallet,&nft_mint_key.pubkey());
    let receiver_token_account = get_associated_token_address(&params.receiver_wallet, &nft_mint_key.pubkey());
    let metadata_address = find_metadata_pda(&nft_mint_key.pubkey());
    let edition_address = find_master_edition_pda(&nft_mint_key.pubkey());

    let account_init_build = program
        .request()
        .accounts(nft_accounts::AccountInit{
            mint: nft_mint_key.pubkey(),
            token_account: nft_token_account,
            mint_authority: payer.pubkey(),
            rent: Pubkey::from_str(SYSTEM_RENT_ID).unwrap(),
            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(),
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
            associated_token_program: Pubkey::from_str(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID).unwrap(),
        })
        .args(nft_instructions::AccountInit);


    let mint_build = program
        .request()
        .accounts(nft_accounts::MintNFT{
            metadata: metadata_address, //
            master_edition: edition_address, //
            mint: nft_mint_key.pubkey(), //
            token_account: nft_token_account, //
            mint_authority: payer.pubkey(), //
            rent: Pubkey::from_str(SYSTEM_RENT_ID).unwrap(), //
            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(), //
            token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap(), //
            token_metadata_program: Pubkey::from_str(MPL_TOKEN_METADATA_ACCOUNT).unwrap()
        })
        .args(nft_instructions::MintTo{
            title: "test1".to_string(),
            uri: "https://bafybeiagelxwxuundel3rjqydvunf24llrg4e2a5l4fje27arsdzhdgaqu.ipfs.nftstorage.link/0.json".to_string(),
            symbol: "KR".to_string()
        });


    let verify_build = program
        .request()
        .accounts(nft_accounts::SetAndVerifyCollection{
            metadata_account: find_metadata_pda(&nft_mint_key.pubkey()),
            collection_authority: payer.pubkey(),
            payer: payer.pubkey(),
            update_authority: payer.pubkey(),
            collection_mint: Pubkey::from_str(memorise_mint_account).unwrap(),
            collection_metadata: find_metadata_pda(&Pubkey::from_str(memorise_mint_account).unwrap()),
            collection_master_edition: find_master_edition_pda(&Pubkey::from_str(memorise_mint_account).unwrap()),
            system_program: Pubkey::from_str(SYSTEM_PROGRAM_ID).unwrap(),
            rent:Pubkey::from_str(SYSTEM_RENT_ID).unwrap(),
            spl_token_metadata:Pubkey::from_str(MPL_TOKEN_METADATA_ACCOUNT).unwrap(),

            //for transfer
            mint_account: nft_mint_key.pubkey(),
            sender_token_account: nft_token_account,
            receiver_token_account: receiver_token_account,
            receiver_wallet: params.receiver_wallet,
            associated_token_program: Pubkey::from_str(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID).unwrap(),
            spl_token_program: Pubkey::from_str(SPL_PROGRAM_ID).unwrap()

        })
        .args(nft_instructions::CollectionAdd);



    let call_res = program
        .request()
        .instruction(
            account_init_build.instructions()?.first().unwrap().to_owned()
        )
        .instruction(
            mint_build.instructions()?.first().unwrap().to_owned()
        )
        .instruction(
            verify_build.instructions()?.first().unwrap().to_owned()
        )
        .signer(&nft_mint_key)
        .signer(&payer)
        .send()?;
    println!("call res {}", call_res);
    println!("nft mint key {}", nft_mint_key.pubkey().to_string());

    Ok(nft_mint_key.pubkey())
}