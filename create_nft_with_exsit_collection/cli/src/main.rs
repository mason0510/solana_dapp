use std::cmp::min;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::signature::read_keypair_file;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, ClientError, Cluster, EventContext};
use mpl_token_metadata::instruction::{set_and_verify_collection, update_metadata_accounts, update_metadata_accounts_v2, verify_collection};

use solana_client::{
    rpc_client::RpcClient,
    rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes, MemcmpEncoding},
    rpc_config::{RpcProgramAccountsConfig, RpcAccountInfoConfig},
};
use solana_sdk::program_pack::Pack;
use spl_token::{state::{Mint, Account}};
use solana_account_decoder::{UiAccountEncoding};

use anyhow::Result;
use solana_sdk::{client, system_program};
// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;
use clap::Parser;
// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};
use rand::rngs::OsRng;
use std::rc::Rc;
use std::str::FromStr;
use std::time::Duration;
use anchor_client::anchor_lang::prelude::Pubkey;
use anchor_client::solana_client::nonce_utils::get_account;
use anchor_client::solana_sdk::nonce::State;
use mpl_token_metadata::pda::{find_master_edition_account, find_metadata_account};
use mpl_token_metadata::state::{DataV2, Metadata, PREFIX, TokenMetadataAccount};
use solana_client::nonce_utils::get_account_with_commitment;
use solana_sdk::account_info::AccountInfo;
use solana_sdk::instruction::Instruction;
use spl_associated_token_account::create_associated_token_account;
use spl_associated_token_account::solana_program::pubkey;

#[derive(Parser, Debug)]
pub struct Opts {
    #[clap(long)]
    pub token_address: Pubkey,
    #[clap(long)]
    pub bridge_contract_pid: Pubkey,
    #[clap(long)]
    pub receiver_wallet: Pubkey,
}

const SPL_PROGRAM_ID: &'static str = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";

//const BRIDGE_CONTRACT: &'static str = "F1eqWRT9CUruLk9n4mX4fCYKDqSde9yLtveRaywx6vwn";
//const TOKEN_ADDRESS: &'static str = "7YYNXbfwd5i5scpez18fTkEh2MRHJXoMHPffnWNcpFYf";
const SENDER: &'static str = "9hUYW9s2c98GfjZb6JvW62BYEt3ryxGmeMBkhgSqmZtW";
const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: &'static str = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
const SYSTEM_PROGRAM_ID: &'static str = "11111111111111111111111111111111";
const SYSTEM_RENT_ID: &'static str = "SysvarRent111111111111111111111111111111111";
const MPL_TOKEN_METADATA_ACCOUNT: &'static str = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";

pub fn find_metadata_pda(mint: &Pubkey) -> Pubkey {
    let (pda, _bump) = find_metadata_account(mint);

    pda
}

pub fn find_master_edition_pda(mint: &Pubkey) -> Pubkey {

    let (pda, _bump) = find_master_edition_account(mint);
    pda
}

pub fn get_acc(address: Pubkey) -> solana_sdk::account::Account{
    let rpc_client = RpcClient::new(
        "https://api.devnet.solana.com".to_string(),
    );
    rpc_client
        .get_account_with_commitment(&address, CommitmentConfig::processed()).unwrap()
        .value
        .ok_or(ClientError::AccountNotFound).unwrap()
}

pub fn get_update_auth(){
    let mint_key = Pubkey::from_str("6P64iPbit6iUbwMj55pXXEu7GxUaE9jPVqWCmomyqPph").unwrap();
    let metadata_account = find_metadata_pda(&mint_key);
    println!("metadata_account {}",metadata_account);

    //let metadata_account = Pubkey::from_str("GHM5Z4jKr2jwC8iqERVoSn9u6W7jodDcWYcD7BmdYWA2").unwrap();
    let mut account3 = get_acc(metadata_account.clone());
    let account4 = AccountInfo::new(&metadata_account,
                                    false, false,
                                    &mut account3.lamports, account3.data.as_mut_slice(),
                                    &account3.owner,
                                    account3.executable, account3.rent_epoch);
    println!("account1_info_key {}",account4.owner);
    let acc5 : Metadata = Metadata::from_account_info(&account4).unwrap();
    println!("account1_info_key {:?}",acc5);
}

// This example assumes a local validator is running with the programs
// deployed at the addresses given by the CLI args.
fn main() -> Result<()> {
    println!("Starting test...");
    let opts = Opts::parse();

    // Wallet and cluster params.
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id_1.json"))
        .expect("Example requires a keypair file");
    let url = Cluster::Custom(
        "https://api.devnet.solana.com".to_string(),
        "wss://api.devnet.solana.com/".to_string(),
    );

    // Client.
    let client = Client::new_with_options(url, Rc::new(payer), CommitmentConfig::processed());
    //let rpcClient = RpcClient::new("https://api.devnet.solana.com".to_string());
    //let account1 = get_account(&rpcClient,
     //                         &Pubkey::from_str("GHM5Z4jKr2jwC8iqERVoSn9u6W7jodDcWYcD7BmdYWA2").unwrap()).unwrap();
    // Run tests.
    //let program = client.program(params.bridge_contract_pid);
    //let account2 : solana_sdk::account::Account = program.account(Pubkey::from_str("GHM5Z4jKr2jwC8iqERVoSn9u6W7jodDcWYcD7BmdYWA2").unwrap()).unwrap();
    //let test2 = AccountInfo::from("1");
    //let test3 : Metadata = Metadata::from_account_info(&account2).unwrap();
    get_update_auth();
    verify_nft_collection(&client, opts)?;
    Ok(())
}

fn verify_nft_collection(client: &Client, params: Opts) -> Result<()> {
    let program = client.program(params.bridge_contract_pid); //BGzwb76jQtDP9hpho7WDSzFSYSJUbbZq4Jkpggb4aiuA
    let authority = program.payer();
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json")).expect("Example requires a keypair file");
    println!("start request");
    /***
    [writable] Metadata account
[signer] Collection Update authority
[signer] payer
`[] Update Authority of Collection NFT and NFT
[] Mint of the Collection
[] Metadata Account of the Collection
[] MasterEdition2 Account of the Collection Token

 ctx.accounts.token_metadata_program.key(),
            ctx.accounts.metadata.key(),
            collection_pda.key(),
            ctx.accounts.payer.key(),

            ctx.accounts.authority.key(),
            collection_mint.key(),
            ctx.accounts.collection_metadata.key(),
            ctx.accounts.collection_master_edition.key(),
            Some(ctx.accounts.collection_authority_record.key()),

             program_id: Pubkey,
    metadata: Pubkey,
    collection_authority: Pubkey,
    payer: Pubkey,

    collection_mint: Pubkey,
    collection: Pubkey,
    collection_master_edition_account: Pubkey,
    collection_authority_record: Option<Pubkey>,

    */
    println!("mpl_token_metadata::ID {}",mpl_token_metadata::ID);
    println!("spl_token::ID {}",spl_token::id());
    let collection_mint_key = Pubkey::from_str("6P64iPbit6iUbwMj55pXXEu7GxUaE9jPVqWCmomyqPph").unwrap();

    let ix_1 = update_metadata_accounts_v2(
        Pubkey::from_str(MPL_TOKEN_METADATA_ACCOUNT).unwrap(),
        find_metadata_pda(&Pubkey::from_str("6P64iPbit6iUbwMj55pXXEu7GxUaE9jPVqWCmomyqPph").unwrap()),
        payer.pubkey(),
        None,
        Some(DataV2 {
            name: "kingwo's memorise collection".to_string(),
            symbol: "KM".to_string(),
            uri: "https://nftstorage.link/ipfs/bafybeiewf455qyr56n2wkgn43p5e2c3ymh6wp6lm3ocd5dt5ear6bdwbw4/collection.json".to_string(),
            seller_fee_basis_points: 0u16,
            creators: None,
            collection: None,
            uses: None
        }),
        None,
        None,
    );

    let ix_2 = verify_collection(mpl_token_metadata::ID,
                                 Pubkey::from_str("GHM5Z4jKr2jwC8iqERVoSn9u6W7jodDcWYcD7BmdYWA2").unwrap(),
                                 payer.pubkey(),
                                 payer.pubkey(),
                                 //Pubkey::from_str("5wEmePkkXAWYYvvWQDv4Mbenma1jWvzCbt3rK9ihmrqH").unwrap(),
                                 collection_mint_key.clone(),
                                 find_metadata_pda(&collection_mint_key),
                                 find_master_edition_pda(&collection_mint_key),
                                 None);
    let call_res = program
        .request()
      .instruction(
            ix_1 as Instruction
            //create_associated_token_account(&payer.pubkey(), &params.receiver_wallet, &params.token_address)
        ).signer(&payer);

    println!("call_res {}", call_res.send()?);
    //let counter_account: Counter = program.account(counter.pubkey())?;

    //assert_eq!(counter_account.count, 0);

    println!("hello success!");

    Ok(())
}